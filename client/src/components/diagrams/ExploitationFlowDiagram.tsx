import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Zap, Target, Shield, AlertCircle, Clock, User, ArrowRight } from 'lucide-react';
import MermaidDiagram from './MermaidDiagram';

interface ExploitationStep {
  id: string;
  title: string;
  description: string;
  technique: string;
  tool?: string;
  duration?: string;
  difficulty: 'easy' | 'medium' | 'hard' | 'expert';
  success: boolean;
  evidence?: string[];
  mitre_technique?: string;
  next_steps?: string[];
}

interface ExploitationFlowProps {
  findingId?: number;
  initialSteps?: ExploitationStep[];
  editable?: boolean;
  mode?: 'timeline' | 'flowchart' | 'sequence' | 'attack-tree';
}

export default function ExploitationFlowDiagram({ 
  findingId, 
  initialSteps = [], 
  editable = false,
  mode = 'flowchart'
}: ExploitationFlowProps) {
  const [steps, setSteps] = useState<ExploitationStep[]>(initialSteps);
  const [viewMode, setViewMode] = useState<'timeline' | 'flowchart' | 'sequence' | 'attack-tree'>(mode);
  const [selectedStep, setSelectedStep] = useState<string | null>(null);
  const [editingStep, setEditingStep] = useState<string | null>(null);

  // Load exploitation flow from finding data
  useEffect(() => {
    if (findingId && steps.length === 0) {
      // Fetch finding data and extract exploitation flow
      fetch(`/api/findings/${findingId}`)
        .then(res => res.json())
        .then(finding => {
          if (finding.exploitationFlow && finding.exploitationFlow.steps) {
            const flowSteps = finding.exploitationFlow.steps.map((step: any) => ({
              id: step.id,
              title: step.title,
              description: step.description,
              technique: step.techniques?.[0] || '',
              tool: step.tools?.[0] || '',
              duration: step.duration || '',
              difficulty: 'medium' as const,
              success: step.success || false,
              evidence: step.evidence || [],
              mitre_technique: step.techniques?.[0] || '',
              next_steps: []
            }));
            setSteps(flowSteps);
          }
        })
        .catch(err => console.error('Failed to load finding exploitation flow:', err));
    } else if (initialSteps.length > 0 && steps.length === 0) {
      // Use provided initial steps
      setSteps(initialSteps);
    }
  }, [findingId, initialSteps, steps.length]);

  const generateMermaidChart = () => {
    let chart = '';
    
    switch (viewMode) {
      case 'timeline':
        chart = generateTimelineChart();
        break;
      case 'flowchart':
        chart = generateFlowChart();
        break;
      case 'sequence':
        chart = generateSequenceChart();
        break;
      case 'attack-tree':
        chart = generateAttackTreeChart();
        break;
    }
    
    return chart;
  };

  const generateTimelineChart = () => {
    if (steps.length === 0) return 'timeline\n  title Exploitation Timeline\n  No steps available';
    
    let chart = 'timeline\n  title Exploitation Timeline\n';
    
    steps.forEach((step, index) => {
      const status = step.success ? '✓' : '✗';
      chart += `  ${step.title} : ${status} ${step.technique}`;
      if (step.tool) chart += ` (${step.tool})`;
      chart += '\n';
    });
    
    return chart;
  };

  const generateFlowChart = () => {
    if (steps.length === 0) return 'flowchart TD\n  A[No exploitation steps available]';
    
    let chart = 'flowchart TD\n';
    
    steps.forEach((step, index) => {
      const nodeId = step.id;
      const nextSteps = step.next_steps || [];
      
      chart += `  ${nodeId}["${step.title}<br/>${step.technique}"]:::${step.success ? 'success' : 'failure'}\n`;
      
      if (index < steps.length - 1) {
        const nextStep = steps[index + 1];
        chart += `  ${nodeId} --> ${nextStep.id}\n`;
      }
      
      nextSteps.forEach(nextStep => {
        if (nextStep !== steps[index + 1]?.id) {
          chart += `  ${nodeId} --> ${nextStep}\n`;
        }
      });
    });
    
    chart += '\n  classDef success fill:#10b981,stroke:#059669,stroke-width:2px,color:#ffffff\n';
    chart += '  classDef failure fill:#ef4444,stroke:#dc2626,stroke-width:2px,color:#ffffff\n';
    
    return chart;
  };

  const generateSequenceChart = () => {
    if (steps.length === 0) return 'sequenceDiagram\n  participant A as Attacker\n  participant T as Target\n  A->>T: No steps available';
    
    let chart = 'sequenceDiagram\n  participant A as Attacker\n  participant T as Target\n';
    
    steps.forEach(step => {
      const arrow = step.success ? '->>' : '-x';
      chart += `  A${arrow}T: ${step.title}\n`;
      if (step.description) {
        chart += `  Note over A,T: ${step.description}\n`;
      }
    });
    
    return chart;
  };

  const generateAttackTreeChart = () => {
    if (steps.length === 0) return 'flowchart TD\n  Root[No attack tree available]';
    
    let chart = 'flowchart TD\n  Root[Complete Compromise]\n';
    
    steps.forEach((step, index) => {
      chart += `  Root --> ${step.id}["${step.title}"]\n`;
      chart += `  ${step.id}:::${step.success ? 'success' : 'failure'}\n`;
    });
    
    chart += '\n  classDef success fill:#10b981,stroke:#059669,stroke-width:2px,color:#ffffff\n';
    chart += '  classDef failure fill:#ef4444,stroke:#dc2626,stroke-width:2px,color:#ffffff\n';
    
    return chart;
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold text-white">Exploitation Flow</h3>
        <div className="flex items-center space-x-4">
          <Select value={viewMode} onValueChange={(value: any) => setViewMode(value)}>
            <SelectTrigger className="w-48 bg-[hsl(var(--secondary-bg))] border-[hsl(var(--border))]">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="flowchart">Flowchart</SelectItem>
              <SelectItem value="timeline">Timeline</SelectItem>
              <SelectItem value="sequence">Sequence</SelectItem>
              <SelectItem value="attack-tree">Attack Tree</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      <Card className="bg-[hsl(var(--primary-bg))] border-[hsl(var(--secondary-bg))]">
        <CardContent className="p-6">
          <MermaidDiagram 
            chart={generateMermaidChart()}
            id={`exploitation-flow-${findingId || 'default'}`}
          />
        </CardContent>
      </Card>

      {steps.length > 0 && (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {steps.map((step, index) => (
            <Card key={step.id} className="bg-[hsl(var(--primary-bg))] border-[hsl(var(--secondary-bg))]">
              <CardHeader>
                <CardTitle className="flex items-center justify-between">
                  <span className="flex items-center space-x-2">
                    <Badge variant={step.success ? "default" : "destructive"}>
                      Step {index + 1}
                    </Badge>
                    <span>{step.title}</span>
                  </span>
                  {step.success ? (
                    <Badge className="bg-green-600">Success</Badge>
                  ) : (
                    <Badge variant="destructive">Failed</Badge>
                  )}
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <p className="text-gray-300">{step.description}</p>
                
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div>
                    <span className="text-gray-400">Technique:</span>
                    <p className="text-white">{step.technique || step.mitre_technique}</p>
                  </div>
                  {step.tool && (
                    <div>
                      <span className="text-gray-400">Tool:</span>
                      <p className="text-white">{step.tool}</p>
                    </div>
                  )}
                  {step.duration && (
                    <div>
                      <span className="text-gray-400">Duration:</span>
                      <p className="text-white">{step.duration}</p>
                    </div>
                  )}
                  <div>
                    <span className="text-gray-400">Difficulty:</span>
                    <Badge variant="outline" className="ml-2">
                      {step.difficulty}
                    </Badge>
                  </div>
                </div>

                {step.evidence && step.evidence.length > 0 && (
                  <div>
                    <span className="text-gray-400 text-sm">Evidence:</span>
                    <div className="mt-2 space-y-1">
                      {step.evidence.map((evidence, idx) => (
                        <div key={idx} className="flex items-center space-x-2 text-sm">
                          <div className="w-2 h-2 bg-[hsl(var(--accent-green))] rounded-full"></div>
                          <span className="text-gray-300">{evidence}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}